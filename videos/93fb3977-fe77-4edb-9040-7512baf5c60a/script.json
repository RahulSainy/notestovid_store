[{"slide_number": "1", "title": "SOLID Principles of Programming", "slide_type": "Title Slide", "content": "No Content", "image_desc": "No Image Description", "video_desc": "software design principles", "narration": "Welcome to this presentation on the SOLID principles of programming. These principles are a set of guidelines intended to make software designs more understandable flexible and maintainable. Let's dive in and explore each principle in detail.", "image_urls": ["No Image Found"], "image_path": "data/videos/93fb3977-fe77-4edb-9040-7512baf5c60a/images/image_1.webp", "video_urls": ["https://videos.pexels.com/video-files/2887463/2887463-sd_960_540_25fps.mp4"], "video_path": "data/videos/93fb3977-fe77-4edb-9040-7512baf5c60a/images/video_1.mp4"}, {"slide_number": "2", "title": "Introduction to SOLID", "slide_type": "Image with Caption", "content": "SOLID is an acronym representing five design principles.\nThese principles aim to reduce dependencies.\nThey promote code reusability and maintainability.", "image_desc": "SOLID principles acronym. Type: illustration", "video_desc": "", "narration": "SOLID is an acronym that stands for five key principles of objectoriented design. These principles when applied correctly help to reduce tight coupling between different parts of your code. By adhering to SOLID you can create software that is easier to understand modify and extend over time leading to increased code reusability and reduced maintenance costs.", "image_urls": ["https://miro.medium.com/v2/resize:fit:751/0*8LdtE9X2NZawt3a3.png"], "image_path": "data/videos/93fb3977-fe77-4edb-9040-7512baf5c60a/images/image_2.webp", "video_urls": ["No Video Found"], "video_path": "data/videos/93fb3977-fe77-4edb-9040-7512baf5c60a/images/video_2.mp4"}, {"slide_number": "3", "title": "The Five SOLID Principles", "slide_type": "Image with Caption", "content": "Single Responsibility Principle (SRP)\nOpen/Closed Principle (OCP)\nLiskov Substitution Principle (LSP)\nInterface Segregation Principle (ISP)\nDependency Inversion Principle (DIP)", "image_desc": "List of SOLID principles. Type: text", "video_desc": "", "narration": "The SOLID principles consist of five distinct guidelines. These are the Single Responsibility Principle the OpenClosed Principle the Liskov Substitution Principle the Interface Segregation Principle and the Dependency Inversion Principle. Each principle addresses a specific aspect of software design and together they form a powerful toolkit for building robust and maintainable applications.", "image_urls": ["https://raw.githubusercontent.com/gopikrishnareddy93/SOLID-Principles/master/images/solid_class_design_principles.png"], "image_path": "data/videos/93fb3977-fe77-4edb-9040-7512baf5c60a/images/image_3.webp", "video_urls": ["No Video Found"], "video_path": "data/videos/93fb3977-fe77-4edb-9040-7512baf5c60a/images/video_3.mp4"}, {"slide_number": "4", "title": "Single Responsibility Principle (SRP)", "slide_type": "Image Right", "content": "A class should have only one reason to change.\nFocus on high cohesion.\nAvoid \"god classes\" that do too much.", "image_desc": "Single responsibility principle example. Type: diagram", "video_desc": "", "narration": "The Single Responsibility Principle states that a class should have only one reason to change. This means that a class should have only one job or responsibility. By adhering to this principle you create classes that are highly cohesive meaning they focus on a single welldefined purpose avoiding the creation of god classes that attempt to handle too many unrelated tasks.", "image_urls": ["https://miro.medium.com/v2/resize:fit:778/1*7np8DmvPn0ZkP71g-WpzOA.png"], "image_path": "data/videos/93fb3977-fe77-4edb-9040-7512baf5c60a/images/image_4.webp", "video_urls": ["No Video Found"], "video_path": "data/videos/93fb3977-fe77-4edb-9040-7512baf5c60a/images/video_4.mp4"}, {"slide_number": "5", "title": "Open/Closed Principle (OCP)", "slide_type": "Image Right", "content": "Software entities should be open for extension.\nBut closed for modification.\nUse abstraction to achieve this.", "image_desc": "Open closed principle example. Type: diagram", "video_desc": "", "narration": "The OpenClosed Principle dictates that software entities such as classes modules and functions should be open for extension but closed for modification. This means you should be able to add new functionality without altering the existing code. Abstraction through the use of interfaces and abstract classes is a key technique for achieving this.", "image_urls": ["https://www.cs.sjsu.edu/faculty/pearce/modules/lectures/ood/principles/ocp_files/image001.jpg"], "image_path": "data/videos/93fb3977-fe77-4edb-9040-7512baf5c60a/images/image_5.webp", "video_urls": ["No Video Found"], "video_path": "data/videos/93fb3977-fe77-4edb-9040-7512baf5c60a/images/video_5.mp4"}, {"slide_number": "6", "title": "Liskov Substitution Principle (LSP)", "slide_type": "Image Right", "content": "Subtypes must be substitutable for their base types.\nEnsure inheritance is used correctly.\nAvoid unexpected behavior when replacing a base class with a derived class.", "image_desc": "Liskov substitution principle example. Type: diagram", "video_desc": "", "narration": "The Liskov Substitution Principle states that subtypes must be substitutable for their base types without altering the correctness of the program. In simpler terms if you have a base class any derived class should be able to be used in its place without causing unexpected behavior. This principle emphasizes the importance of using inheritance correctly and ensuring that derived classes adhere to the contract defined by their base classes.", "image_urls": ["https://www.javabrahman.com/images/LiskovSubstitutionPrinciple.png"], "image_path": "data/videos/93fb3977-fe77-4edb-9040-7512baf5c60a/images/image_6.webp", "video_urls": ["No Video Found"], "video_path": "data/videos/93fb3977-fe77-4edb-9040-7512baf5c60a/images/video_6.mp4"}, {"slide_number": "7", "title": "Interface Segregation Principle (ISP)", "slide_type": "Image Right", "content": "Clients should not be forced to depend on methods they do not use.\nCreate smaller, more specific interfaces.\nAvoid large, monolithic interfaces.", "image_desc": "Interface segregation principle example. Type: diagram", "video_desc": "", "narration": "The Interface Segregation Principle advises that clients should not be forced to depend on methods they do not use. This means that large monolithic interfaces should be broken down into smaller more specific interfaces so that clients only need to implement the methods that are relevant to them. By adhering to this principle you reduce coupling and increase the flexibility of your code.", "image_urls": ["http://stg-tud.github.io/sedc/Lecture/ws13-14/Images/ISP-ATM-OneInterface.png"], "image_path": "data/videos/93fb3977-fe77-4edb-9040-7512baf5c60a/images/image_7.webp", "video_urls": ["No Video Found"], "video_path": "data/videos/93fb3977-fe77-4edb-9040-7512baf5c60a/images/video_7.mp4"}, {"slide_number": "8", "title": "Dependency Inversion Principle (DIP)", "slide_type": "Image Right", "content": "High-level modules should not depend on low-level modules.\nBoth should depend on abstractions.\nAbstractions should not depend on details. Details should depend on abstractions.", "image_desc": "Dependency inversion principle example. Type: diagram", "video_desc": "", "narration": "The Dependency Inversion Principle states that highlevel modules should not depend on lowlevel modules both should depend on abstractions. Furthermore abstractions should not depend on details details should depend on abstractions. This principle promotes loose coupling by inverting the traditional dependency structure making your code more flexible and testable.", "image_urls": ["https://miro.medium.com/v2/resize:fit:601/1*XyXbJ8c2qW_cdVf9MJiQLg.png"], "image_path": "data/videos/93fb3977-fe77-4edb-9040-7512baf5c60a/images/image_8.webp", "video_urls": ["No Video Found"], "video_path": "data/videos/93fb3977-fe77-4edb-9040-7512baf5c60a/images/video_8.mp4"}]