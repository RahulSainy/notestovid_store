[{"title": "Queues", "content": ["- A **queue** is a non-primitive linear data structure.", "Elements are inserted at one end (**rear**) and deleted at the other end (**front**).", "Operates on a **First-In-First-Out (FIFO)** principle."], "image_desc": "A line of people waiting in a queue", "narration": "*Queue* ek non-primitive linear data structure hai. Isme elements ek end se insert kiye jaate hain, jisko *rear* kehte hain, aur dusre end se delete kiye jaate hain, jisko *front* kehte hain. Queue *First-In-First-Out (FIFO)* principle par kaam karta hai.", "slide_number": "1", "image_url": "https://cdn6.dissolve.com/p/D1028_2_390/D1028_2_390_1200.jpg", "image_path": "data/videos/6ed7d7a1-b36d-4f99-965a-68ed50b2b51a/images/image_1.webp"}, {"title": "Pictorial Representation", "content": ["- **Front**: The end from which elements are removed.", "**Rear**: The end where new elements are added."], "image_desc": "A diagram showing a queue with front and rear pointers", "narration": "*Front* woh end hai jahan se elements remove kiye jaate hain aur *rear* woh end hai jahan new elements add kiye jaate hain.", "slide_number": "2", "image_url": "https://i.ytimg.com/vi/pGhBd04VKjE/maxresdefault.jpg", "image_path": "data/videos/6ed7d7a1-b36d-4f99-965a-68ed50b2b51a/images/image_2.webp"}, {"title": "Empty Queue", "content": ["- **Empty Queue**: \n  '''\n  Front = -1, Rear = -1\n  '''"], "image_desc": "A diagram showing an empty queue", "narration": "Jab queue khali hota hai, to *Front* aur *Rear* dono -1 pe hote hain.", "slide_number": "3", "image_url": "https://i.ytimg.com/vi/SGDRiEzn3ds/maxresdefault.jpg", "image_path": "data/videos/6ed7d7a1-b36d-4f99-965a-68ed50b2b51a/images/image_3.webp"}, {"title": "One Element Queue", "content": ["- **One Element Queue**: \n  '''\n  Front = 0, Rear = 0\n  [20]\n  '''"], "image_desc": "A diagram showing a queue with one element", "narration": "Jab queue mein ek element hota hai, to *Front* aur *Rear* dono 0 pe hote hain.", "slide_number": "4", "image_url": "https://cdn.educba.com/academy/wp-content/uploads/2019/12/Queue-Data-Structure1.jpg", "image_path": "data/videos/6ed7d7a1-b36d-4f99-965a-68ed50b2b51a/images/image_4.webp"}, {"title": "Three Element Queue", "content": ["- **Three Element Queue**:\n  '''\n  Front = 0, Rear = 2\n  [20, 30, 40]\n  '''"], "image_desc": "A diagram showing a queue with three elements", "narration": "Jab queue mein teen elements hote hain, to *Front* 0 pe aur *Rear* 2 pe hota hai.", "slide_number": "5", "image_url": "https://ucarecdn.com/931105a4-8e51-429d-837a-1ee411a562e6/", "image_path": "data/videos/6ed7d7a1-b36d-4f99-965a-68ed50b2b51a/images/image_5.webp"}, {"title": "Operations on a Queue", "content": ["- **Insertion**: Add an element to the rear.", "**Deletion**: Remove an element from the front.", "**Traversal**: Access all elements in the queue."], "image_desc": "A diagram showing the insertion and deletion operations on a queue", "narration": "Queue pe yeh operations perform kiye jaate hain: *Insertion* - rear pe element add karna, *Deletion* - front se element remove karna, aur *Traversal* - queue mein saare elements ko access karna.", "slide_number": "6", "image_url": "https://i.ytimg.com/vi/ORzzHD6a7rE/maxresdefault.jpg", "image_path": "data/videos/6ed7d7a1-b36d-4f99-965a-68ed50b2b51a/images/image_6.webp"}, {"title": "Static Implementation (Using Arrays)", "content": ["- **Static Implementation**: Uses a fixed-size array to store elements.", "**Insertion**: Add an element to the rear of the array.", "**Deletion**: Remove an element from the front of the array."], "image_desc": "A diagram showing a static queue implemented using an array", "narration": "Static implementation mein, elements ko store karne ke liye ek fixed-size array use kiya jaata hai. *Insertion* mein, element ko array ke rear pe add kiya jaata hai aur *Deletion* mein, element ko array ke front se remove kiya jaata hai.", "slide_number": "7", "image_url": "https://media.geeksforgeeks.org/wp-content/uploads/queue-1.png", "image_path": "data/videos/6ed7d7a1-b36d-4f99-965a-68ed50b2b51a/images/image_7.webp"}, {"title": "Insertion Algorithm (Static)", "content": ["1. If 'Rear = (MAXSIZE - 1)', return \"Queue Overflow.\"\n2. Read the element to be inserted.\n3. Increment 'Rear' and place the element in 'QUEUE[Rear]'.\n4. If 'Front = -1', set 'Front = 0'."], "image_desc": "A flowchart showing the insertion algorithm for a static queue", "narration": "Insertion algorithm mein, pehle check kiya jaata hai ki queue full hai ya nahi. Agar 'Rear = (MAXSIZE - 1)' hai, to queue full hai aur \"Queue Overflow\" return kiya jaata hai. Agar queue khali nahi hai, to insert karne wala element read kiya jaata hai, 'Rear' ko increment kiya jaata hai aur element ko 'QUEUE[Rear]' mein place kiya jaata hai. Agar 'Front = -1' hai, to 'Front' ko 0 pe set kiya jaata hai.", "slide_number": "8", "image_url": "https://1.bp.blogspot.com/-ipb1LDPZVXo/VxNci4gk7mI/AAAAAAAAADw/FsKWX8J97IgovdUhDexDUmvs9vkt3yP3gCK4B/s1600/insertion+sort.png", "image_path": "data/videos/6ed7d7a1-b36d-4f99-965a-68ed50b2b51a/images/image_8.webp"}, {"title": "Deletion Algorithm (Static)", "content": ["1. If 'Front = -1', return \"Queue Underflow.\"\n2. Save 'QUEUE[Front]' in a temporary variable.\n3. Increment 'Front'.\n4. If 'Front > Rear', reset 'Front' and 'Rear' to -1."], "image_desc": "A flowchart showing the deletion algorithm for a static queue", "narration": "Deletion algorithm mein, pehle check kiya jaata hai ki queue khali hai ya nahi. Agar 'Front = -1' hai, to queue khali hai aur \"Queue Underflow\" return kiya jaata hai. Agar queue khali nahi hai, to 'QUEUE[Front]' ko ek temporary variable mein save kiya jaata hai, 'Front' ko increment kiya jaata hai aur agar 'Front > Rear' hai, to 'Front' aur 'Rear' ko -1 pe reset kiya jaata hai.", "slide_number": "9", "image_url": "https://i.ytimg.com/vi/rHggmEx-fm0/maxresdefault.jpg?sqp=-oaymwEmCIAKENAF8quKqQMa8AEB-AH-CYAC0AWKAgwIABABGCkgUyh_MA8=&rs=AOn4CLDIPJYQK1kvWobnzPD-DO5dRaxtaw", "image_path": "data/videos/6ed7d7a1-b36d-4f99-965a-68ed50b2b51a/images/image_9.webp"}, {"title": "Example Code (Static)", "content": ["'''c\n#include <stdio.h>\n#include <stdlib.h>\n#define MAXSIZE 5\n\nint queue[MAXSIZE];\nint front, rear;\n\nvoid initialize() {\n    front = rear = -1;\n}\n\nvoid insert() {\n    if (rear == MAXSIZE - 1) {\n        printf(\"Queue Overflow\\n\");\n        return;\n    }\n    int num;\n    printf(\"Enter element to insert: \");\n    scanf(\"%d\", &num);\n    rear++;\n    queue[rear] = num;\n    if (front == -1) front = 0;\n}\n\nvoid delete() {\n    if (front == -1) {\n        printf(\"Queue Underflow\\n\");\n        return;\n    }\n    int num = queue[front];\n    printf(\"Deleted element: %d\\n\", num);\n    front++;\n    if (front > rear) front = rear = -1;\n}\n\nvoid traverse() {\n    if (front == -1) {\n        printf(\"Queue is empty\\n\");\n        return;\n    }\n    for (int i = front; i <= rear; i++) {\n        printf(\"%d \", queue[i]);\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    initialize();\n    int choice;\n    while (1) {\n        printf(\"1. Insert\\n2. Delete\\n3. Traverse\\n4. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n        switch (choice) {\n            case 1: insert(); break;\n            case 2: delete(); break;\n            case 3: traverse(); break;\n            case 4: exit(0); break;\n            default: printf(\"Invalid choice\\n\");\n        }\n    }\n    return 0;\n}\n'''"], "image_desc": "A screenshot of the example code for a static queue", "narration": "Yeh example code static queue ke liye hai. Isme *initialize*, *insert*, *delete* aur *traverse* functions define kiye gaye hain. *main* function mein, user se choice input li jaati hai aur uske hisaab se operations perform kiye jaate hain.", "slide_number": "10", "image_url": "https://media.cheggcdn.com/study/842/842cc511-dc57-43a2-9146-54951cf94d61/image.jpg", "image_path": "data/videos/6ed7d7a1-b36d-4f99-965a-68ed50b2b51a/images/image_10.webp"}, {"title": "Dynamic Implementation (Using Linked Lists)", "content": ["- **Dynamic Implementation**: Uses a linked list to store elements.", "**Insertion**: Add a new node to the rear of the linked list.", "**Deletion**: Remove the first node from the linked list."], "image_desc": "A diagram showing a dynamic queue implemented using a linked list", "narration": "Dynamic implementation mein, elements ko store karne ke liye ek linked list use kiya jaata hai. *Insertion* mein, ek new node ko linked list ke rear pe add kiya jaata hai aur *Deletion* mein, linked list ke pehle node ko remove kiya jaata hai.", "slide_number": "11", "image_url": "https://static.javatpoint.com/ds/images/linked-list-implementation-of-queue.png", "image_path": "data/videos/6ed7d7a1-b36d-4f99-965a-68ed50b2b51a/images/image_11.webp"}, {"title": "Insertion Algorithm (Dynamic)", "content": ["1. Allocate memory for a new node.\n2. Read the element and set its link to NULL.\n3. If 'Front' is NULL, set both 'Front' and 'Rear' to the new node.\n4. Otherwise, link the current 'Rear' to the new node and update 'Rear'."], "image_desc": "A flowchart showing the insertion algorithm for a dynamic queue", "narration": "*Insertion* algorithm mein, pehle ek new node ke liye memory allocate ki jaati hai. Fir, insert karne wala element read kiya jaata hai aur uske link ko NULL pe set kiya jaata hai. Agar 'Front' NULL hai, to 'Front' aur 'Rear' dono ko new node pe set kiya jaata hai. Varna, current 'Rear' ko new node se link kiya jaata hai aur 'Rear' ko update kiya jaata hai.", "slide_number": "12", "image_url": "https://online.visual-paradigm.com/repository/images/071eb41e-e899-4afc-899a-25092c7f0ff7/flowchart-design/flowchart-example-representing-algorithm.png", "image_path": "data/videos/6ed7d7a1-b36d-4f99-965a-68ed50b2b51a/images/image_12.webp"}, {"title": "Deletion Algorithm (Dynamic)", "content": ["1. If 'Front' is NULL, return \"Queue Underflow.\"\n2. Save the front element and move 'Front' to the next node.\n3. If 'Front' becomes NULL, set 'Rear' to NULL as well."], "image_desc": "A flowchart showing the deletion algorithm for a dynamic queue", "narration": "*Deletion* algorithm mein, pehle check kiya jaata hai ki queue khali hai ya nahi. Agar 'Front' NULL hai, to queue khali hai aur \"Queue Underflow\" return kiya jaata hai. Agar queue khali nahi hai, to front element ko ek temporary variable mein save kiya jaata hai, 'Front' ko next node pe move kiya jaata hai aur agar 'Front' NULL ho jaata hai, to 'Rear' ko bhi NULL pe set kiya jaata hai.", "slide_number": "13", "image_url": "https://i.ytimg.com/vi/rHggmEx-fm0/maxresdefault.jpg?sqp=-oaymwEmCIAKENAF8quKqQMa8AEB-AH-CYAC0AWKAgwIABABGCkgUyh_MA8=&rs=AOn4CLDIPJYQK1kvWobnzPD-DO5dRaxtaw", "image_path": "data/videos/6ed7d7a1-b36d-4f99-965a-68ed50b2b51a/images/image_13.webp"}, {"title": "Example Code (Dynamic)", "content": ["'''c\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int data;\n    struct Node* next;\n};\n\nstruct Queue {\n    struct Node* front;\n    struct Node* rear;\n};\n\nvoid initialize(struct Queue* q) {\n    q->front = q->rear = NULL;\n}\n\nvoid insert(struct Queue* q) {\n    struct Node* temp = (struct Node*)malloc(sizeof(struct Node));\n    int num;\n    printf(\"Enter element to insert: \");\n    scanf(\"%d\", &num);\n    temp->data = num;\n    temp->next = NULL;\n    if (q->rear == NULL) {\n        q->front = q->rear = temp;\n        return;\n    }\n    q->rear->next = temp;\n    q->rear = temp;\n}\n\nvoid delete(struct Queue* q) {\n    if (q->front == NULL) {\n        printf(\"Queue Underflow\\n\");\n        return;\n    }\n    struct Node* temp = q->front;\n    printf(\"Deleted element: %d\\n\", temp->data);\n    q->front = q->front->next;\n    if (q->front == NULL) q->rear = NULL;\n    free(temp);\n}\n\nvoid traverse(struct Queue* q) {\n    if (q->front == NULL) {\n        printf(\"Queue is empty\\n\");\n        return;\n    }\n    struct Node* temp = q->front;\n    while (temp != NULL) {\n        printf(\"%d \", temp->data);\n        temp = temp->next;\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    struct Queue q;\n    initialize(&q);\n    int choice;\n    while (1) {\n        printf(\"1. Insert\\n2. Delete\\n3. Traverse\\n4. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n        switch (choice) {\n            case 1: insert(&q); break;\n            case 2: delete(&q); break;\n            case 3: traverse(&q); break;\n            case 4: exit(0); break;\n            default: printf(\"Invalid choice\\n\");\n        }\n    }\n    return 0;\n}\n'''"], "image_desc": "A screenshot of the example code for a dynamic queue", "narration": "Yeh example code dynamic queue ke liye hai. Isme *initialize*, *insert*, *delete* aur *traverse* functions define kiye gaye hain. *main* function mein, user se choice input li jaati hai aur uske hisaab se operations perform kiye jaate hain.", "slide_number": "14", "image_url": "https://i.ytimg.com/vi/tn6XE7Gs3mk/hqdefault.jpg", "image_path": "data/videos/6ed7d7a1-b36d-4f99-965a-68ed50b2b51a/images/image_14.webp"}, {"title": "Circular Queues", "content": ["- **Circular Queue**: A queue where the rear pointer wraps around to the beginning of the array when it reaches the end.", "**Insertion**: Insert an element at the rear, wrapping around if necessary.", "**Deletion**: Remove an element from the front, wrapping around if necessary."], "image_desc": "A diagram showing a circular queue", "narration": "Circular queue ek aisa queue hai jisme rear pointer array ke end pe pahunchne ke baad shuruat se wrap kar jaata hai. *Insertion* mein, element ko rear pe insert kiya jaata hai, aur agar jarurat ho to wrap kiya jaata hai. *Deletion* mein, element ko front se remove kiya jaata hai, aur agar jarurat ho to wrap kiya jaata hai.", "slide_number": "15", "image_url": "https://cdncontribute.geeksforgeeks.org/wp-content/uploads/Circular-queue.png", "image_path": "data/videos/6ed7d7a1-b36d-4f99-965a-68ed50b2b51a/images/image_15.webp"}, {"title": "Insertion and Deletion Algorithms (Circular)", "content": ["1. **Insertion**: \n   - Check if the queue is full using the condition '(Front == (Rear + 1) % MAXSIZE)'.\n   - Insert an element and update the 'Rear' index circularly.\n  \n2. **Deletion**: \n   - Check if the queue is empty using 'Front == -1'.\n   - Remove the element from the front and update the 'Front' index circularly."], "image_desc": "A flowchart showing the insertion and deletion algorithms for a circular queue", "narration": "*Insertion* algorithm mein, pehle check kiya jaata hai ki queue full hai ya nahi. Agar '(Front == (Rear + 1) % MAXSIZE)' hai, to queue full hai. Agar queue full nahi hai, to element ko insert kiya jaata hai aur 'Rear' index ko circularly update kiya jaata hai. *Deletion* algorithm mein, pehle check kiya jaata hai ki queue khali hai ya nahi. Agar 'Front == -1' hai, to queue khali hai. Agar queue khali nahi hai, to element ko front se remove kiya jaata hai aur 'Front' index ko circularly update kiya jaata hai.", "slide_number": "16", "image_url": "https://media.geeksforgeeks.org/wp-content/uploads/Circular-queue_1.png", "image_path": "data/videos/6ed7d7a1-b36d-4f99-965a-68ed50b2b51a/images/image_16.webp"}, {"title": "Example Code (Circular)", "content": ["'''c\n#include <stdio.h>\n#include <stdlib.h>\n#define MAXSIZE 5\n\nint cqueue[MAXSIZE];\nint front = -1, rear = -1;\n\nvoid insert() {\n    if ((rear + 1) % MAXSIZE == front) {\n        printf(\"Queue Overflow\\n\");\n        return;\n    }\n    int num;\n    printf(\"Enter element to insert: \");\n    scanf(\"%d\", &num);\n    if (front == -1) front = rear = 0;\n    else rear = (rear + 1) % MAXSIZE;\n    cqueue[rear] = num;\n}\n\nvoid delete() {\n    if (front == -1) {\n        printf(\"Queue Underflow\\n\");\n        return;\n    }\n    printf(\"Deleted element: %d\\n\", cqueue[front]);\n    if (front == rear) front = rear = -1;\n    else front = (front + 1) % MAXSIZE;\n}\n\nvoid display() {\n    if (front == -1) {\n        printf(\"Queue is empty\\n\");\n        return;\n    }\n    int i = front;\n    printf(\"Circular Queue elements: \");\n    while (1) {\n        printf(\"%d \", cqueue[i]);\n        if (i == rear) break;\n        i = (i + 1) % MAXSIZE;\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    int choice;\n    while (1) {\n        printf(\"1. Insert\\n2. Delete\\n3. Display\\n4. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n        switch (choice) {\n            case 1: insert(); break;\n            case 2: delete(); break;\n            case 3: display(); break;\n            case 4: exit(0); break;\n            default: printf(\"Invalid choice\\n\");\n        }\n    }\n    return 0;\n}\n'''"], "image_desc": "A screenshot of the example code for a circular queue", "narration": "Yeh example code circular queue ke liye hai. Isme *insert*, *delete* aur *display* functions define kiye gaye hain. *main* function mein, user se choice input li jaati hai aur uske hisaab se operations perform kiye jaate hain.", "slide_number": "17", "image_url": "http://btechsmartclass.com/data_structures/ds_images/circular_Queue_Output_1.PNG", "image_path": "data/videos/6ed7d7a1-b36d-4f99-965a-68ed50b2b51a/images/image_17.webp"}, {"title": "Priority Queue", "content": ["- **Priority Queue**: A queue where elements are processed based on their priority.", "**Higher priority elements are served before lower priority ones.**", "**Elements with the same priority are processed in the order they arrive.**"], "image_desc": "A diagram showing a priority queue", "narration": "Priority queue ek aisa queue hai jisme elements ko unki priority ke hisaab se process kiya jaata hai. High priority elements ko low priority elements se pehle serve kiya jaata hai. Same priority ke elements ko unke aane ke order mein process kiya jaata hai.", "slide_number": "18", "image_url": "https://static.javatpoint.com/ds/images/ds-priority-queue.png", "image_path": "data/videos/6ed7d7a1-b36d-4f99-965a-68ed50b2b51a/images/image_18.webp"}, {"title": "Key Features (Priority Queue)", "content": ["1. Elements with a higher priority are processed first.\n2. Elements with the same priority are processed in the order they arrive."], "image_desc": "A diagram showing the key features of a priority queue", "narration": "Priority queue ke yeh key features hain: High priority elements ko pehle process kiya jaata hai aur same priority ke elements ko unke aane ke order mein process kiya jaata hai.", "slide_number": "19", "image_url": "https://i.ytimg.com/vi/XDxLEUgVDMM/maxresdefault.jpg", "image_path": "data/videos/6ed7d7a1-b36d-4f99-965a-68ed50b2b51a/images/image_19.webp"}, {"title": "Applications (Priority Queue)", "content": ["- **Job scheduling in operating systems**: Prioritize important tasks.", "**Simulation systems**: Model real-world scenarios with priority-based events."], "image_desc": "A diagram showing the applications of a priority queue", "narration": "Priority queue ke yeh applications hain: Operating systems mein job scheduling, jisme important tasks ko prioritize kiya jaata hai, aur simulation systems, jisme priority-based events ke saath real-world scenarios ko model kiya jaata hai.", "slide_number": "20", "image_url": "https://www.simplilearn.com/ice9/free_resources_article_thumb/Insertion_Max_heap_Implementation.png", "image_path": "data/videos/6ed7d7a1-b36d-4f99-965a-68ed50b2b51a/images/image_20.webp"}, {"title": "Representation (Priority Queue)", "content": ["1. **One-way List**: Nodes contain data and priority, sorted by priority.\n2. **Array Representation**: Separate queues for each priority level."], "image_desc": "A diagram showing the representation of a priority queue", "narration": "Priority queue ko yeh do tarikon se represent kiya jaata hai: One-way list, jisme nodes mein data aur priority hota hai aur yeh priority ke hisaab se sorted hote hain, aur array representation, jisme har priority level ke liye alag queue hota hai.", "slide_number": "21", "image_url": "https://static.javatpoint.com/ds/images/ds-priority-queue2.png", "image_path": "data/videos/6ed7d7a1-b36d-4f99-965a-68ed50b2b51a/images/image_21.webp"}, {"title": "Applications of Queues", "content": ["- **Processor scheduling (Round Robin)**: Fair allocation of CPU time to processes.", "**Customer service systems (e.g., railway ticket reservations)**: Manage customer wait times.", "**Print server routines**: Handle print jobs in a queue."], "image_desc": "A diagram showing the applications of queues", "narration": "Queue ke yeh applications hain: Processor scheduling mein Round Robin algorithm, jisme CPU time ko processes mein fair allocation kiya jaata hai, customer service systems mein, jaise railway ticket reservations, jisme customer wait times ko manage kiya jaata hai, aur print server routines, jisme print jobs ko queue mein handle kiya jaata hai.", "slide_number": "22", "image_url": "https://lezline.com/wp-content/uploads/2021/02/Capture.png", "image_path": "data/videos/6ed7d7a1-b36d-4f99-965a-68ed50b2b51a/images/image_22.webp"}]